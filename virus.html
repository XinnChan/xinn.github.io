<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>GPU Shader Stress — eXCe (Auto Start + Checkbox)</title>
<style>
  html,body{margin:0;height:100%;background:#0b0b10;color:#cfd3ff;font-family:system-ui,Segoe UI,Roboto,Ubuntu,Arial}
  #wrap{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr}
  #topbar{display:flex;gap:12px;align-items:center;padding:8px 10px;background:#101218;border-bottom:1px solid #1e2233;flex-wrap:wrap}
  #stats{margin-left:auto;font-variant-numeric:tabular-nums}
  #canvas-wrap{position:relative}
  canvas{display:block;width:100%;height:100%}
  .toggle{display:flex;align-items:center;gap:8px;background:#0f1422;padding:6px 10px;border-radius:10px;border:1px solid #1d2842}
  #warn{position:absolute;left:8px;bottom:8px;background:#181c2a;border:1px solid #2e3552;color:#ffe1a8;padding:6px 8px;border-radius:8px;opacity:.9;display:none}
</style>
</head>
<body>
<div id="wrap">
  <div id="topbar">
    <label class="toggle">
      <input id="stressToggle" type="checkbox" checked/>
      <span>GPU Stress</span>
    </label>
    <div id="stats">FPS: <b id="fps">—</b> | Frame ms: <b id="ms">—</b></div>
  </div>
  <div id="canvas-wrap">
    <canvas id="c"></canvas>
    <div id="warn"></div>
  </div>
</div>

<script>
(function(){
  // ====== Setting “ekstrim” ======
  const SUPER_SCALE = 1.25;   // 1.25–2.0 → makin berat (awas iPhone bisa context lost)
  const MAX_ITER    = 1500.0; // Raymarch steps
  const STEP_SCALE  = 0.75;   // Raymarch step
  const SPP         = 8;      // Samples per pixel
  const USE_FOG     = 1;      // 1 = ON
  const DO_STALL    = 100;      // 1 = ON (ALU busy loop)

  // ====== WebGL init ======
  const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 3));
  const canvas = document.getElementById('c');
  const toggle = document.getElementById('stressToggle');
  const warn = document.getElementById('warn');

  const gl = canvas.getContext('webgl', {
    antialias:false, alpha:false, depth:false, stencil:false,
    preserveDrawingBuffer:false, powerPreference:'high-performance',
    desynchronized:true, failIfMajorPerformanceCaveat:false
  }) || canvas.getContext('experimental-webgl');

  if(!gl){ alert('WebGL tidak tersedia'); return; }

  function showWarn(msg){
    warn.style.display='block';
    warn.textContent = msg;
    clearTimeout(showWarn._t);
    showWarn._t = setTimeout(()=> warn.style.display='none', 3500);
  }

  canvas.addEventListener('webglcontextlost', (e)=>{
    e.preventDefault();
    showWarn('Context Lost! Turunkan SUPER_SCALE atau pakai perangkat lebih kuat.');
    cancelAnimationFrame(rafId);
  }, false);

  const gotDeriv = !!gl.getExtension('OES_standard_derivatives');
  const precisionHeader = gotDeriv ? 'precision highp float;' : 'precision mediump float;';

  const vert = `
    attribute vec2 aPos;
    varying vec2 vUv;
    void main(){
      vUv = aPos*0.5 + 0.5;
      gl_Position = vec4(aPos,0.0,1.0);
    }
  `;

  const frag = `
    ${precisionHeader}
    #define PI 3.141592653589793
    varying vec2 vUv;
    uniform vec2 uRes;
    uniform float uTime;
    uniform vec3 uCamPos;
    uniform mat3 uCamMat;

    float hash11(float p){ p = fract(p*0.1031); p *= p + 33.33; p *= p + p; return fract(p); }
    vec2  hash21(float p){ return fract(sin(vec2(p,p+1.234))*vec2(43758.5453,22578.145912)); }
    float noise3(vec3 x){
      vec3 p=floor(x), f=fract(x);
      f=f*f*(3.0-2.0*f);
      float n = p.x+p.y*57.0+p.z*113.0;
      float a = mix(mix(mix(hash11(n+0.0), hash11(n+1.0), f.x),
                        mix(hash11(n+57.0),hash11(n+58.0),f.x), f.y),
                    mix(mix(hash11(n+113.0),hash11(n+114.0),f.x),
                        mix(hash11(n+170.0),hash11(n+171.0),f.x), f.y), f.z);
      return a;
    }

    float deMandelbulb(vec3 p){
      vec3 z = p;
      float dr = 1.0;
      float r = 0.0;
      const float Power = 8.0;
      for (int i=0; i<64; i++){
        r = length(z);
        if (r>2.5) break;
        float theta = acos(z.z/r);
        float phi   = atan(z.y, z.x);
        dr = pow(r, Power-1.0)*Power*dr + 1.0;
        float zr = pow(r, Power);
        theta *= Power; phi *= Power;
        z = zr*vec3(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)) + p;
      }
      return 0.5*log(r)*r/dr;
    }

    float mapSDF(vec3 p){
      float t = uTime*0.2;
      p += 0.25*vec3(
        noise3(p*1.2 + vec3(0.0, t, 4.2)),
        noise3(p*1.1 + vec3(2.4, 1.7+t, 0.3)),
        noise3(p*1.3 + vec3(1.1, 0.2, t))
      );
      return deMandelbulb(p);
    }

    vec3 calcNormal(vec3 p){
      float eps = 0.0008;
      vec2 k = vec2(1.0, -1.0)*0.5773;
      return normalize( k.xyy*mapSDF(p + k.xyy*eps) +
                        k.yyx*mapSDF(p + k.yyx*eps) +
                        k.yxy*mapSDF(p + k.yxy*eps) +
                        k.xxx*mapSDF(p + k.xxx*eps) );
    }

    float softShadow(vec3 ro, vec3 rd, float k){
      float res = 1.0;
      float t = 0.02;
      for(int i=0;i<48;i++){
        float h = mapSDF(ro + rd*t);
        res = min(res, k*h/t);
        t += clamp(h, 0.01, 0.2);
        if(res<0.001||t>3.0) break;
      }
      return clamp(res,0.0,1.0);
    }

    float ao(vec3 p, vec3 n){
      float occ = 0.0;
      float sc = 0.02;
      for(int i=1;i<=6;i++){
        float hr = float(i)*sc;
        float d = mapSDF(p + n*hr);
        occ += (hr - d);
      }
      return clamp(1.0 - occ*1.2, 0.0, 1.0);
    }

    vec3 rayDir(vec2 uv){ return normalize(uCamMat * normalize(vec3(uv, -1.3))); }

    vec3 fogAccum(vec3 ro, vec3 rd, float maxT){
      float T = 1.0;
      vec3  sum = vec3(0.0);
      float t = 0.02;
      for(int i=0;i<64;i++){
        if(t>maxT) break;
        vec3 p = ro + rd*t;
        float dens = clamp(noise3(p*1.3 + uTime*0.15) - 0.45, 0.0, 1.0);
        dens *= 0.8;
        vec3  lightColor = vec3(0.5,0.7,1.0);
        float absorb = exp(-dens*0.25);
        vec3  scatter = lightColor * dens * 0.08;

        sum += T * scatter;
        T *= absorb;

        t += 0.06;
        if(T<0.01) break;
      }
      return sum;
    }

    vec3 shade(vec3 pos, vec3 n, vec3 rd, vec3 ro){
      vec3 lp1 = ro + uCamMat * vec3(0.4, 0.8, -0.2);
      vec3 lp2 = ro + uCamMat * vec3(-0.7, 0.3, -0.4);

      vec3 l1 = normalize(lp1 - pos);
      vec3 l2 = normalize(lp2 - pos);

      float d1 = max(dot(n,l1),0.0);
      float d2 = max(dot(n,l2),0.0);

      float sh1 = softShadow(pos + n*0.0016, l1, 8.0);
      float sh2 = softShadow(pos + n*0.0016, l2, 8.0);

      float amb = ao(pos, n);
      float spec1 = pow(max(dot(reflect(-l1,n), -rd), 0.0), 32.0);
      float spec2 = pow(max(dot(reflect(-l2,n), -rd), 0.0), 28.0);

      vec3 base = vec3(0.25,0.7,1.2 + 0.2*sin(pos.y*2.0+uTime*2.0));
      vec3 col =
        (0.12 + 0.88*amb)*base*0.35 +
        d1*vec3(1.0,0.9,0.8)*0.9*sh1 +
        d2*vec3(0.8,0.9,1.0)*0.75*sh2 +
        (spec1*0.5 + spec2*0.35);

      return col/(1.0+col);
    }

    vec3 renderSample(vec2 uv){
      uv.x *= uRes.x/uRes.y;

      vec3 ro = uCamPos;
      vec3 rd = rayDir(uv);

      float t = 0.0;
      float d = 1.0;
      float eps = 0.0008;
      float tMax = 6.0;
      vec3 bg = vec3(0.02,0.03,0.06) + 0.15*vec3(uv.y*0.5+0.5);
      vec3 fogCol = vec3(0.0);

      #if ${USE_FOG}
      float ft = 0.0;
      for(int i=0;i<1024;i++){
        if(ft>tMax) break;
        vec3 p = ro + rd*ft;
        float h = mapSDF(p);
        fogCol += fogAccum(ro, rd, min(tMax, ft + clamp(h, 0.05, 0.2)));
        ft += clamp(h, 0.05, 0.2);
        if(h<0.02){ t = ft; break; }
      }
      if(t<=0.0){
        vec3 col = bg + fogCol;
        return pow(col, vec3(0.85));
      }
      #endif

      int steps = int(${MAX_ITER}.0);
      for(int i=0;i<5000;i++){
        if(i>=steps) break;
        vec3 pos = ro + rd*t;
        d = mapSDF(pos);
        if(d<eps){
          vec3 n = calcNormal(pos);
          vec3 col = shade(pos, n, rd, ro);
          #if ${USE_FOG}
          col += fogCol;
          #endif
          return pow(col, vec3(0.85));
        }
        t += d * (0.35 * ${STEP_SCALE});
        if(t>tMax) break;
      }
      vec3 col = bg;
      #if ${USE_FOG}
      col += fogCol;
      #endif
      return pow(col, vec3(0.85));
    }

    void doStall(){
      #if ${DO_STALL}
      float s=0.0;
      for(int i=0;i<120000;i++){
        s += sin(float(i))*0.0000001;
      }
      #endif
    }

    void main(){
      vec3 acc = vec3(0.0);
      for(int s=0; s<${SPP}; s++){
        vec2 j = hash21(uTime*123.0 + float(s)*17.123);
        vec2 uv = (vUv*2.0 - 1.0) + (j - 0.5)/uRes;
        acc += renderSample(uv);
      }
      acc /= float(${SPP});
      gl_FragColor = vec4(acc,1.0);
      doStall();
    }
  `;

  function makeShader(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      console.error(gl.getShaderInfoLog(s));
      throw new Error('Shader compile error');
    }
    return s;
  }

  const vs = makeShader(gl.VERTEX_SHADER, vert);
  const fs = makeShader(gl.FRAGMENT_SHADER, frag);
  const prog = gl.createProgram();
  gl.attachShader(prog, vs);
  gl.attachShader(prog, fs);
  gl.linkProgram(prog);
  if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){
    console.error(gl.getProgramInfoLog(prog));
    throw new Error('Link error');
  }
  gl.useProgram(prog);

  const aPos   = gl.getAttribLocation(prog, 'aPos');
  const uRes   = gl.getUniformLocation(prog, 'uRes');
  const uTime  = gl.getUniformLocation(prog, 'uTime');
  const uCamPos= gl.getUniformLocation(prog, 'uCamPos');
  const uCamMat= gl.getUniformLocation(prog, 'uCamMat');

  const quad = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quad);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1,  1,-1,  -1,1,
     1,-1,  1, 1,  -1,1
  ]), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(aPos);
  gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

  // Kamera orbit auto
  let angle = 0.0, camDist = 2.2;

  // Resize dengan super scale
  function resize(){
    const w = window.innerWidth;
    const h = window.innerHeight;
    const targetW = Math.floor(w * dpr * SUPER_SCALE);
    const targetH = Math.floor(h * dpr * SUPER_SCALE);
    canvas.width = targetW;
    canvas.height = targetH;
    canvas.style.width = w+'px';
    canvas.style.height = h+'px';
    gl.viewport(0,0,targetW,targetH);
    gl.uniform2f(uRes, targetW, targetH);
  }
  window.addEventListener('resize', resize);
  resize();

  // FPS meter
  const fpsEl = document.getElementById('fps');
  const msEl = document.getElementById('ms');
  let prev = performance.now(), acc=0, frames=0;
  function meter(dt){
    acc += dt; frames++;
    if(acc>=500){
      const fps = Math.round(1000.0/(dt || 16.7));
      fpsEl.textContent = fps;
      msEl.textContent = dt.toFixed(1);
      acc=0; frames=0;
    }
  }

  function normalize3(a){ const l=Math.hypot(a[0],a[1],a[2])||1; return [a[0]/l,a[1]/l,a[2]/l]; }
  function cross(a,b){ return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
  function neg3(a){ return [-a[0],-a[1],-a[2]]; }

  // Render loop
  let rafId = 0, running = false;
  function frame(now){
    if(!running) return;
    const dt = now - prev; prev = now; meter(dt);

    angle += 0.2 * (dt/1000);
    const yaw = angle + 0.3;
    const pitch = -0.25;
    const cx = Math.cos(yaw)*Math.cos(pitch);
    const cy = Math.sin(pitch);
    const cz = Math.sin(yaw)*Math.cos(pitch);

    const camPos = [cx*camDist, cy*camDist, cz*camDist];
    const forward = normalize3(neg3(camPos));
    const right = normalize3(cross(forward, [0,1,0]));
    const up = normalize3(cross(right, forward));

    gl.uniform1f(uTime, now*0.001);
    gl.uniform3f(uCamPos, camPos[0], camPos[1], camPos[2]);
    gl.uniformMatrix3fv(uCamMat, false, new Float32Array([
      right[0], up[0], forward[0],
      right[1], up[1], forward[1],
      right[2], up[2], forward[2],
    ]));

    gl.drawArrays(gl.TRIANGLES, 0, 6);
    rafId = requestAnimationFrame(frame);
  }

  // Checkbox logic: ON = jalan, OFF = berhenti
  function startStress(){
    if(running) return;
    running = true;
    prev = performance.now();
    resize();
    rafId = requestAnimationFrame(frame);
  }
  function stopStress(){
    running = false;
    cancelAnimationFrame(rafId);
    gl.clearColor(0.05,0.06,0.09,1);
    gl.clear(gl.COLOR_BUFFER_BIT);
  }
  toggle.addEventListener('change', ()=>{
    if(toggle.checked) startStress(); else stopStress();
  });

  // Auto-start saat buka halaman
  startStress();

})();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="user-scalable=no" />
  <!-- <title>volumeshader_bm</title> -->
  <title>VIRUS WEB HP KENTANK</title>
  <style>
    body {
      background: #131115;
      margin: 0;
    }
    #c1 {
      background: #fbf7fe;
      position: fixed;
      left: 0px;
      top: 0px;
    }
    #btn {
      position: fixed;
      left: 0px;
      top: 0px;
      z-index: 10;
    }
    #main {
      transform-origin: 0px 0px;
      position: fixed;
      left: 0px;
      top: 0px;
    }
    #config {
      position: fixed;
      left: 0px;
      top: 30px;
      display: none;
      z-index: 10;
    }
  </style>
</head>
<body style="overflow-x:hidden;overflow-y:hidden">
  <div id="main">
    <canvas id="c1" width="2096" height="2096"></canvas>
    <span>不支持canvas浏览器</span>
  </div>

  <button id="btn">CONFIG</button>
  <div id="config">
    <textarea id="kernel" cols="30" rows="10"></textarea>
    <br />
    <button id="apply">APPLY</button>
    <button id="cancle">CANCLE</button>
  </div>

  <!-- === COMPAT LAYER: WebGPU → WebGL2 → WebGL1 + GLSL converters === -->
  <script>
  // 1) Context selection
  async function initContext(canvas) {
    if ('gpu' in navigator) {
      try {
        const adapter = await navigator.gpu.requestAdapter();
        if (adapter) {
          const device = await adapter.requestDevice();
          return { api: 'webgpu', adapter, device };
        }
      } catch {}
    }
    const gl2 = canvas.getContext('webgl2', { antialias:false, preserveDrawingBuffer:false });
    if (gl2) return { api:'webgl2', gl:gl2 };
    const gl1 = canvas.getContext('webgl', { antialias:false, preserveDrawingBuffer:false })
             || canvas.getContext('experimental-webgl', { antialias:false, preserveDrawingBuffer:false });
    if (gl1) return { api:'webgl1', gl:gl1 };
    return { api:'none' };
  }

  // 2) GLSL compatibility helpers (100 ↔ 300 es)
  function toGLSL300(src, type) {
    if (!/^#version\s+300\s+es/m.test(src)) {
      src = `#version 300 es\n` + src.replace(/^#version.*$/m, '');
    }
    if (type === 'vertex') {
      src = src.replace(/\battribute\b/g, 'in').replace(/\bvarying\b/g, 'out');
    } else {
      src = src.replace(/\bvarying\b/g, 'in');
      if (!/^\s*out\s+vec4\s+fragColor\s*;/m.test(src)) src = `out vec4 fragColor;\n` + src;
      src = src.replace(/\bgl_FragColor\b/g, 'fragColor');
    }
    src = src.replace(/\btexture2D\b/g, 'texture').replace(/\btextureCube\b/g, 'texture');
    return src;
  }
  function toGLSL100(src, type) {
    if (!/^#version\s+100/m.test(src)) {
      src = `#version 100\n` + src.replace(/^#version.*$/m, '');
    }
    if (type === 'vertex') {
      src = src.replace(/\bin\b/g, 'attribute').replace(/\bout\b/g, 'varying');
    } else {
      src = src.replace(/^\s*out\s+vec4\s+fragColor\s*;\s*/m, '');
      src = src.replace(/\bfragColor\b/g, 'gl_FragColor').replace(/\bin\b/g, 'varying');
    }
    src = src.replace(/\btexture\(/g, 'texture2D(');
    return src;
  }

  // 3) Compile/link util
  function createProgram(gl, vsSrc, fsSrc, isWebGL2) {
    if (!/precision\s+(lowp|mediump|highp)\s+float\s*;/.test(fsSrc)) {
      fsSrc = `precision highp float;\n` + fsSrc;
    }
    const vsrc = isWebGL2 ? toGLSL300(vsSrc, 'vertex')   : toGLSL100(vsSrc, 'vertex');
    const fsrc = isWebGL2 ? toGLSL300(fsSrc, 'fragment') : toGLSL100(fsSrc, 'fragment');

    const vs = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vs, vsrc);
    gl.compileShader(vs);
    if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
      throw new Error('Vertex compile error:\n' + gl.getShaderInfoLog(vs));
    }

    const fs = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fs, fsrc);
    gl.compileShader(fs);
    if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
      throw new Error('Fragment compile error:\n' + gl.getShaderInfoLog(fs));
    }

    const prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
      throw new Error('Link error:\n' + gl.getProgramInfoLog(prog));
    }
    return prog;
  }
  </script>

  <!-- === APP LOGIC (asli kamu + compat) === -->
  <script>
  //alert("trigonometric and inverse trigonometric functions test.\ncreated by cznull@bilibili");
  var cx, cy;
  var glposition;
  var glright;
  var glforward;
  var glup;
  var glorigin;
  var glx;
  var gly;
  var gllen;
  var canvas;
  var gl;
  var date = new Date();
  var md = 0,mx,my;
  var t2,t1 = date.getTime();
  var mx = 0, my = 0, mx1 = 0, my1 = 0, lasttimen = 0;
  var ml = 0, mr = 0, mm = 0;
  var len = 1.6;
  var ang1 = 2.8;
  var ang2 = 0.4;
  var cenx = 0.0;
  var ceny = 0.0;
  var cenz = 0.0;

  var KERNEL = "float kernal(vec3 ver){\n" +
      "   vec3 a;\n" +
      "float b,c,d,e;\n" +
      "   a=ver;\n" +
      "   for(int i=0;i<5;i++){\n" +
      "       b=length(a);\n" +
      "       c=atan(a.y,a.x)*8.0;\n" +
      "       e=1.0/b;\n" +
      "       d=acos(a.z/b)*8.0;\n" +
      "       b=pow(b,8.0);\n" +
      "       a=vec3(b*sin(d)*cos(c),b*sin(d)*sin(c),b*cos(d))+ver;\n" +
      "       if(b>6.0){\n" +
      "           break;\n" +
      "       }\n" +
      "   }" +
      "   return 4.0-a.x*a.x-a.y*a.y-a.z*a.z;" +
      "}";

  var vertshade;
  var fragshader;
  var shaderProgram;

  function ontimer() {
    ang1 += 0.01;
    draw();
    window.requestAnimationFrame(ontimer);
  }

  // ==== Mouse / Touch Events (asli kamu) ====
  document.addEventListener("mousedown", function (ev) {
    var oEvent = ev || event;
    if (oEvent.button == 0) { ml = 1; mm = 0; }
    if (oEvent.button == 2) { mr = 1; mm = 0; }
    mx = oEvent.clientX; my = oEvent.clientY;
  }, false);

  document.addEventListener("mouseup", function (ev) {
    var oEvent = ev || event;
    if (oEvent.button == 0) ml = 0;
    if (oEvent.button == 2) mr = 0;
  }, false);

  document.addEventListener("mousemove", function (ev) {
    var oEvent = ev || event;
    if (ml == 1) {
      ang1 += (oEvent.clientX - mx) * 0.002;
      ang2 += (oEvent.clientY - my) * 0.002;
      if (oEvent.clientX != mx || oEvent.clientY != my) mm = 1;
    }
    if (mr == 1) {
      var l = len * 4.0 / (cx + cy);
      cenx += l * (-(oEvent.clientX - mx) * Math.sin(ang1) - (oEvent.clientY - my) * Math.sin(ang2) * Math.cos(ang1));
      ceny += l * ((oEvent.clientY - my) * Math.cos(ang2));
      cenz += l * ((oEvent.clientX - mx) * Math.cos(ang1) - (oEvent.clientY - my) * Math.sin(ang2) * Math.sin(ang1));
      if (oEvent.clientX != mx || oEvent.clientY != my) mm = 1;
    }
    mx = oEvent.clientX; my = oEvent.clientY;
  }, false);

  document.addEventListener("mousewheel", function (ev) {
    ev.preventDefault();
    var oEvent = ev || event;
    len *= Math.exp(-0.001 * oEvent.wheelDelta);
  }, false);

  document.addEventListener("touchstart", function (ev) {
    var n = ev.touches.length;
    if (n == 1) {
      var oEvent = ev.touches[0];
      mx = oEvent.clientX; my = oEvent.clientY;
    } else if (n == 2) {
      var oEvent = ev.touches[0];
      mx = oEvent.clientX; my = oEvent.clientY;
      oEvent = ev.touches[1];
      mx1 = oEvent.clientX; my1 = oEvent.clientY;
    }
    lasttimen = n;
  }, false);

  document.addEventListener("touchend", function (ev) {
    var n = ev.touches.length;
    if (n == 1) {
      var oEvent = ev.touches[0];
      mx = oEvent.clientX; my = oEvent.clientY;
    } else if (n == 2) {
      var oEvent = ev.touches[0];
      mx = oEvent.clientX; my = oEvent.clientY;
      oEvent = ev.touches[1];
      mx1 = oEvent.clientX; my1 = oEvent.clientY;
    }
    lasttimen = n;
  }, false);

  document.addEventListener("touchmove", function (ev) {
    ev.preventDefault();
    var n = ev.touches.length;
    if (n == 1 && lasttimen == 1) {
      var oEvent = ev.touches[0];
      ang1 += (oEvent.clientX - mx) * 0.002;
      ang2 += (oEvent.clientY - my) * 0.002;
      mx = oEvent.clientX; my = oEvent.clientY;
    } else if (n == 2) {
      var oEvent = ev.touches[0];
      var oEvent1 = ev.touches[1];
      var l = len * 2.0 / (cx + cy), l1;
      cenx += l * (-(oEvent.clientX + oEvent1.clientX - mx - mx1) * Math.sin(ang1) - (oEvent.clientY + oEvent1.clientY - my - my1) * Math.sin(ang2) * Math.cos(ang1));
      ceny += l * ((oEvent.clientY + oEvent1.clientY - my - my1) * Math.cos(ang2));
      cenz += l * ((oEvent.clientX + oEvent1.clientX - mx - mx1) * Math.cos(ang1) - (oEvent.clientY + oEvent1.clientY - my - my1) * Math.sin(ang2) * Math.sin(ang1));
      l1 = Math.sqrt((mx - mx1) * (mx - mx1) + (my - my1) * (my - my1)+1.0);
      mx = oEvent.clientX; my = oEvent.clientY;
      mx1 = oEvent1.clientX; my1 = oEvent1.clientY;
      l = Math.sqrt((mx - mx1) * (mx - mx1) + (my - my1) * (my - my1) + 1.0);
      len *= l1 / l;
    }
    lasttimen = n;
  }, false);

  document.oncontextmenu = function (event) {
    if (mm == 1) event.preventDefault();
  };

  function draw() {
    date = new Date();
    var t2 = date.getTime();
    // ang1 += (t2 - t1)*0.001;
    t1 = t2;

    gl.uniform1f(glx, cx * 2.0 / (cx + cy));
    gl.uniform1f(gly, cy * 2.0 / (cx + cy));
    gl.uniform1f(gllen, len);
    gl.uniform3f(glorigin,
      len * Math.cos(ang1) * Math.cos(ang2) + cenx,
      len * Math.sin(ang2) + ceny,
      len * Math.sin(ang1) * Math.cos(ang2) + cenz
    );
    gl.uniform3f(glright, Math.sin(ang1), 0, -Math.cos(ang1));
    gl.uniform3f(glup, -Math.sin(ang2) * Math.cos(ang1), Math.cos(ang2), -Math.sin(ang2) * Math.sin(ang1));
    gl.uniform3f(glforward, -Math.cos(ang1) * Math.cos(ang2), -Math.sin(ang2), -Math.sin(ang1) * Math.cos(ang2));

    gl.drawArrays(gl.TRIANGLES, 0, 6);
    // HAPUS gl.finish(); agar tidak stall GPU (lebih aman di iPhone)
  }

  window.onresize = function () {
    cx = document.body.clientWidth;
    cy = document.body.clientHeight;
    if (cx > cy) cx = cy; else cy = cx;
    document.getElementById("main").style.width = 1024 + "px";
    document.getElementById("main").style.height = 1024 + "px";
    document.getElementById("main").style.transform = "scale(" + cx/1024 + "," + cy/1024 + ")";
  };

  window.onload = async function () {
    cx = document.body.clientWidth;
    cy = document.body.clientHeight;
    if (cx > cy) cx = cy; else cy = cx;
    document.getElementById("main").style.width = 1024 + "px";
    document.getElementById("main").style.height = 1024 + "px";
    document.getElementById("main").style.transform = "scale(" + cx/1024 + "," + cy/1024 + ")";

    var positions = [
      -1.0, -1.0, 0.0,
       1.0, -1.0, 0.0,
       1.0,  1.0, 0.0,
      -1.0, -1.0, 0.0,
       1.0,  1.0, 0.0,
      -1.0,  1.0, 0.0
    ];

    var VSHADER_SOURCE =
      "#version 100 \n"+
      "precision highp float;\n" +
      "attribute vec4 position;" +
      "varying vec3 dir, localdir;" +
      "uniform vec3 right, forward, up, origin;" +
      "uniform float x,y;" +
      "void main() {" +
      "   gl_Position = position; " +
      "   dir = forward + right * position.x*x + up * position.y*y;" +
      "   localdir.x = position.x*x;" +
      "   localdir.y = position.y*y;" +
      "   localdir.z = -1.0;" +
      "} ";

    var FSHADER_SOURCE =
      "#version 100 \n" +
      "#define PI 3.14159265358979324\n" +
      "#define M_L 0.3819660113\n" +
      "#define M_R 0.6180339887\n" +
      "#define MAXR 8\n" +
      "#define SOLVER 8\n" +
      "precision highp float;\n" +
      "float kernal(vec3 ver)\n;" +
      "uniform vec3 right, forward, up, origin;\n" +
      "varying vec3 dir, localdir;\n" +
      "uniform float len;\n" +
      "vec3 ver;\n" +
      "int sign;"+
      "float v, v1, v2;\n" +
      "float r1, r2, r3, r4, m1, m2, m3, m4;\n" +
      "vec3 n, reflect;\n" +
      "const float step = 0.002;\n" +
      "vec3 color;\n" +
      "void main() {\n" +
      "   color.r=0.0;\n" +
      "   color.g=0.0;\n" +
      "   color.b=0.0;\n" +
      "   sign=0;\n"+
      "   v1 = kernal(origin + dir * (step*len));\n" +
      "   v2 = kernal(origin);\n" +
      "   for (int k = 2; k < 30002; k++) {\n" +
      "      ver = origin + dir * (step*len*float(k));\n" +
      "      v = kernal(ver);\n" +
      "      if (v > 0.0 && v1 < 0.0) {\n" +
      "         r1 = step * len*float(k - 1);\n" +
      "         r2 = step * len*float(k);\n" +
      "         m1 = kernal(origin + dir * r1);\n" +
      "         m2 = kernal(origin + dir * r2);\n" +
      "         for (int l = 0; l < SOLVER; l++) {\n" +
      "            r3 = r1 * 0.5 + r2 * 0.5;\n" +
      "            m3 = kernal(origin + dir * r3);\n" +
      "            if (m3 > 0.0) {\n" +
      "               r2 = r3;\n" +
      "               m2 = m3;\n" +
      "            }\n" +
      "            else {\n" +
      "               r1 = r3;\n" +
      "               m1 = m3;\n" +
      "            }\n" +
      "         }\n" +
      "         if (r3 < 2.0 * len) {\n" +
      "            sign=1;\n" +
      "            break;\n" +
      "         }\n" +
      "      }\n" +
      "      if (v < v1&&v1>v2&&v1 < 0.0 && (v1*2.0 > v || v1 * 2.0 > v2)) {\n" +
      "         r1 = step * len*float(k - 2);\n" +
      "         r2 = step * len*(float(k) - 2.0 + 2.0*M_L);\n" +
      "         r3 = step * len*(float(k) - 2.0 + 2.0*M_R);\n" +
      "         r4 = step * len*float(k);\n" +
      "         m2 = kernal(origin + dir * r2);\n" +
      "         m3 = kernal(origin + dir * r3);\n" +
      "         for (int l = 0; l < MAXR; l++) {\n" +
      "            if (m2 > m3) {\n" +
      "               r4 = r3;\n" +
      "               r3 = r2;\n" +
      "               r2 = r4 * M_L + r1 * M_R;\n" +
      "               m3 = m2;\n" +
      "               m2 = kernal(origin + dir * r2);\n" +
      "            }\n" +
      "            else {\n" +
      "               r1 = r2;\n" +
      "               r2 = r3;\n" +
      "               r3 = r4 * M_R + r1 * M_L;\n" +
      "               m2 = m3;\n" +
      "               m3 = kernal(origin + dir * r3);\n" +
      "            }\n" +
      "         }\n" +
      "         if (m2 > 0.0) {\n" +
      "            r1 = step * len*float(k - 2);\n" +
      "            r2 = r2;\n" +
      "            m1 = kernal(origin + dir * r1);\n" +
      "            m2 = kernal(origin + dir * r2);\n" +
      "            for (int l = 0; l < SOLVER; l++) {\n" +
      "               r3 = r1 * 0.5 + r2 * 0.5;\n" +
      "               m3 = kernal(origin + dir * r3);\n" +
      "               if (m3 > 0.0) {\n" +
      "                  r2 = r3;\n" +
      "                  m2 = m3;\n" +
      "               }\n" +
      "               else {\n" +
      "                  r1 = r3;\n" +
      "                  m1 = m3;\n" +
      "               }\n" +
      "            }\n" +
      "            if (r3 < 2.0 * len&&r3> step*len) {\n" +
      "               sign=1;\n" +
      "               break;\n" +
      "            }\n" +
      "         }\n" +
      "         else if (m3 > 0.0) {\n" +
      "            r1 = step * len*float(k - 2);\n" +
      "            r2 = r3;\n" +
      "            m1 = kernal(origin + dir * r1);\n" +
      "            m2 = kernal(origin + dir * r2);\n" +
      "            for (int l = 0; l < SOLVER; l++) {\n" +
      "               r3 = r1 * 0.5 + r2 * 0.5;\n" +
      "               m3 = kernal(origin + dir * r3);\n" +
      "               if (m3 > 0.0) {\n" +
      "                  r2 = r3;\n" +
      "                  m2 = m3;\n" +
      "               }\n" +
      "               else {\n" +
      "                  r1 = r3;\n" +
      "                  m1 = m3;\n" +
      "               }\n" +
      "            }\n" +
      "            if (r3 < 2.0 * len&&r3> step*len) {\n" +
      "               sign=1;\n" +
      "               break;\n" +
      "            }\n" +
      "         }\n" +
      "      }\n" +
      "      v2 = v1;\n" +
      "      v1 = v;\n" +
      "   }\n" +
      "   if (sign==1) {\n" +
      "      ver = origin + dir*r3 ;\n" +
      "      r1=ver.x*ver.x+ver.y*ver.y+ver.z*ver.z;\n" +
      "      n.x = kernal(ver - right * (r3*0.00025)) - kernal(ver + right * (r3*0.00025));\n" +
      "      n.y = kernal(ver - up * (r3*0.00025)) - kernal(ver + up * (r3*0.00025));\n" +
      "      n.z = kernal(ver + forward * (r3*0.00025)) - kernal(ver - forward * (r3*0.00025));\n" +
      "      r3 = n.x*n.x+n.y*n.y+n.z*n.z;\n" +
      "      n = n * (1.0 / sqrt(r3));\n" +
      "      ver = localdir;\n" +
      "      r3 = ver.x*ver.x+ver.y*ver.y+ver.z*ver.z;\n" +
      "      ver = ver * (1.0 / sqrt(r3));\n" +
      "      reflect = n * (-2.0*dot(ver, n)) + ver;\n" +
      "      r3 = reflect.x*0.276+reflect.y*0.920+reflect.z*0.276;\n" +
      "      r4 = n.x*0.276+n.y*0.920+n.z*0.276;\n" +
      "      r3 = max(0.0,r3);\n" +
      "      r3 = r3 * r3*r3*r3;\n" +
      "      r3 = r3 * 0.45 + r4 * 0.25 + 0.3;\n" +
      "      n.x = sin(r1*10.0)*0.5+0.5;\n" +
      "      n.y = sin(r1*10.0+2.05)*0.5+0.5;\n" +
      "      n.z = sin(r1*10.0-2.05)*0.5+0.5;\n" +
      "      color = n*r3;\n" +
      "   }\n" +
      "   gl_FragColor = vec4(color.x, color.y, color.z, 1.0);\n" +
      "}";

    canvas = document.getElementById('c1');

    // ==== pilih context ====
    const ctx = await initContext(canvas);
    if (ctx.api === 'none') {
      alert('Tidak ada dukungan WebGPU/WebGL/Canvas2D.'); return;
    }
    if (ctx.api === 'webgpu') {
      console.log('WebGPU tersedia (opsional). Render tetap via WebGL untuk kompatibilitas.');
    }
    gl = ctx.gl || null;
    const isWebGL2 = (ctx.api === 'webgl2');

    // === WebGL1 extensions ===
    if (!isWebGL2 && gl) {
      gl.getExtension('OES_standard_derivatives');
      gl.getExtension('OES_element_index_uint');
      // Tambahan bila perlu:
      // gl.getExtension('OES_texture_float');
      // gl.getExtension('OES_texture_float_linear');
      // gl.getExtension('EXT_color_buffer_float');
    }

    // ==== Compile & link ====
    shaderProgram = createProgram(gl, VSHADER_SOURCE, FSHADER_SOURCE + KERNEL, isWebGL2);
    gl.useProgram(shaderProgram);

    // ==== Attribute & Uniforms ====
    glposition = gl.getAttribLocation(shaderProgram, 'position');
    glright    = gl.getUniformLocation(shaderProgram, 'right');
    glforward  = gl.getUniformLocation(shaderProgram, 'forward');
    glup       = gl.getUniformLocation(shaderProgram, 'up');
    glorigin   = gl.getUniformLocation(shaderProgram, 'origin');
    glx        = gl.getUniformLocation(shaderProgram, 'x');
    gly        = gl.getUniformLocation(shaderProgram, 'y');
    gllen      = gl.getUniformLocation(shaderProgram, 'len');

    // ==== Buffer quad ====
    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(glposition);
    gl.vertexAttribPointer(glposition, 3, gl.FLOAT, false, 0, 0);

    // ==== Viewport adaptif (hindari 4096×4096 yang bikin crash) ====
    function resizeGL() {
      const maxDims = gl.getParameter(gl.MAX_VIEWPORT_DIMS);
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      const base = Math.min(1024, Math.min(maxDims[0], maxDims[1]));
      canvas.width  = Math.floor(base * dpr);
      canvas.height = Math.floor(base * dpr);
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener('resize', resizeGL, { passive:true });
    resizeGL();

    // ==== Mulai render ====
    draw();
    window.requestAnimationFrame(ontimer);

    // ==== UI Config ====
    document.getElementById("kernel").value = KERNEL;
    document.getElementById("btn").addEventListener("click", function() {
      var state = this.innerText == "CONFIG";
      this.innerText = state ? "HIDE" : "CONFIG";
      document.getElementById("config").style.display = state ? "inline" : "none";
    });

    document.getElementById("apply").addEventListener("click", function() {
      KERNEL = document.getElementById("kernel").value;
      // Rebuild full program (paling aman untuk kompat)
      shaderProgram = createProgram(gl, VSHADER_SOURCE, FSHADER_SOURCE + KERNEL, isWebGL2);
      gl.useProgram(shaderProgram);

      glposition = gl.getAttribLocation(shaderProgram, 'position');
      glright    = gl.getUniformLocation(shaderProgram, 'right');
      glforward  = gl.getUniformLocation(shaderProgram, 'forward');
      glup       = gl.getUniformLocation(shaderProgram, 'up');
      glorigin   = gl.getUniformLocation(shaderProgram, 'origin');
      glx        = gl.getUniformLocation(shaderProgram, 'x');
      gly        = gl.getUniformLocation(shaderProgram, 'y');
      gllen      = gl.getUniformLocation(shaderProgram, 'len');

      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.enableVertexAttribArray(glposition);
      gl.vertexAttribPointer(glposition, 3, gl.FLOAT, false, 0, 0);
    });

    document.getElementById("cancle").addEventListener("click", function() {
      document.getElementById("config").style.display = "none";
      document.getElementById("btn").innerText = "CONFIG";
    });
  };
  </script>
</body>
</html>
